package main

import (
	"fmt"
	"math"
)

func createSet(combinaisonBases []int, i int) []int {
	var newCombinaison []int
	newCombinaison = append(newCombinaison, combinaisonBases...)
	newCombinaison = append(newCombinaison, i)
	return newCombinaison
}

func createPossibleSalesSets(
	setsChan chan<- [][]int,
	indexBase int,
	combinaisonsBases [][]int,
	salesNumber int,
	safeGuard chan int,
	maxGoroutines int,
	onEnd CallbackEnd,
) {

	for index := indexBase; index < salesNumber; index++ {

		var otherCombinationBefore []int
		var otherCombination []int
		otherCombinationBefore = append(otherCombinationBefore, combinaisonsBases[1]...)
		//	otherCombination = append(otherCombination, otherCombinationBases...)
		for otherIndex := indexBase; otherIndex < index; otherIndex++ {
			otherCombinationBefore = append(otherCombinationBefore, otherIndex)
		}
		otherCombination = append(otherCombination, otherCombinationBefore...)
		for otherIndex := index + 1; otherIndex < salesNumber; otherIndex++ {
			otherCombination = append(otherCombination, otherIndex)
		}
		newCombinaison := createSet(combinaisonsBases[0], index)

		fmt.Println("send ", newCombinaison, " & ", otherCombination)
		setsChan <- [][]int{newCombinaison, otherCombination}

		for nextIndex := index + 1; nextIndex < salesNumber; nextIndex++ {

			var otherCombinationBases []int
			otherCombinationBases = append(otherCombinationBases, otherCombinationBefore...)
			for otherIndex := indexBase + 1; otherIndex < nextIndex; otherIndex++ {
				otherCombinationBases = append(otherCombinationBases, otherIndex)
			}
			fmt.Println(" => (chan,", nextIndex, "[", newCombinaison, ",", otherCombinationBases, "], ...")
			createPossibleSalesSets(setsChan, nextIndex, [][]int{newCombinaison, otherCombinationBases}, salesNumber, safeGuard, maxGoroutines, onEnd)
		}
	}

	/*newCombinaison := createSet(combinaisonsBases[0], salesNumber-1)
	fmt.Println("send ", newCombinaison, " & ", []int{})
	setsChan <- [][]int{newCombinaison, {}}*/

	if onEnd != nil {
		onEnd()
	}
}

// returns every possible combinaison when dividing X Sales into X bundle
func GetPossibleSaleIndexesSets(salesNumber, maxGoroutines int) [][]int {
	safeGuard := make(chan int, maxGoroutines)
	setsChan := make(chan [][]int)

	// Create sets
	go createPossibleSalesSets(setsChan, 0, [][]int{{}, {}}, salesNumber, safeGuard, maxGoroutines, nil)

	// Find best route
	numberOfSolutions := int(math.Pow(2, float64(salesNumber)) - 1)
	possibleSaleIndexesSets := make([][]int, numberOfSolutions)
	setIndex := 0
	for possibleSaleIndexesSet := range setsChan {
		//fmt.Println(possibleSaleIndexesSet[0], " vs ", possibleSaleIndexesSet[1])
		possibleSaleIndexesSets[setIndex] = possibleSaleIndexesSet[0]
		setIndex++
		if setIndex == numberOfSolutions {
			close(setsChan)
		}
	}

	return possibleSaleIndexesSets
}
